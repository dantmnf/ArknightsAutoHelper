# coding: utf-8

"""
    Penguin Statistics - REST APIs

    Backend APIs for Arknights drop rate statistics website 'Penguin Statistics': https://penguin-stats.io/  # noqa: E501

    OpenAPI spec version: 2.0.0
    Contact: alvissreimu@gmail.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class DropInfo(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'accumulatable': 'bool',
        'bounds': 'Bounds',
        'drop_type': 'str',
        'item_id': 'str',
        'server': 'str',
        'stage_id': 'str',
        'time_range': 'TimeRange',
        'time_range_id': 'str'
    }

    attribute_map = {
        'accumulatable': 'accumulatable',
        'bounds': 'bounds',
        'drop_type': 'dropType',
        'item_id': 'itemId',
        'server': 'server',
        'stage_id': 'stageId',
        'time_range': 'timeRange',
        'time_range_id': 'timeRangeID'
    }

    def __init__(self, accumulatable=None, bounds=None, drop_type=None, item_id=None, server=None, stage_id=None, time_range=None, time_range_id=None):  # noqa: E501
        """DropInfo - a model defined in Swagger"""  # noqa: E501

        self._accumulatable = None
        self._bounds = None
        self._drop_type = None
        self._item_id = None
        self._server = None
        self._stage_id = None
        self._time_range = None
        self._time_range_id = None
        self.discriminator = None

        if accumulatable is not None:
            self.accumulatable = accumulatable
        if bounds is not None:
            self.bounds = bounds
        if drop_type is not None:
            self.drop_type = drop_type
        if item_id is not None:
            self.item_id = item_id
        if server is not None:
            self.server = server
        if stage_id is not None:
            self.stage_id = stage_id
        if time_range is not None:
            self.time_range = time_range
        if time_range_id is not None:
            self.time_range_id = time_range_id

    @property
    def accumulatable(self):
        """Gets the accumulatable of this DropInfo.  # noqa: E501

        If one dropInfo is accumulatable, it means the drop data (quantity and times) of this item in the stage can be accumulated with future time ranges.For example, item ap_supply_lt_010 in stage main_01-07 has several drop infos under 3 time ranges A, B and C.If `accumulatable` for A is false while for B and C are true, then we say the \"latest max accumulatable time ranges are B~C.\"  # noqa: E501

        :return: The accumulatable of this DropInfo.  # noqa: E501
        :rtype: bool
        """
        return self._accumulatable

    @accumulatable.setter
    def accumulatable(self, accumulatable):
        """Sets the accumulatable of this DropInfo.

        If one dropInfo is accumulatable, it means the drop data (quantity and times) of this item in the stage can be accumulated with future time ranges.For example, item ap_supply_lt_010 in stage main_01-07 has several drop infos under 3 time ranges A, B and C.If `accumulatable` for A is false while for B and C are true, then we say the \"latest max accumulatable time ranges are B~C.\"  # noqa: E501

        :param accumulatable: The accumulatable of this DropInfo.  # noqa: E501
        :type: bool
        """

        self._accumulatable = accumulatable

    @property
    def bounds(self):
        """Gets the bounds of this DropInfo.  # noqa: E501


        :return: The bounds of this DropInfo.  # noqa: E501
        :rtype: Bounds
        """
        return self._bounds

    @bounds.setter
    def bounds(self, bounds):
        """Sets the bounds of this DropInfo.


        :param bounds: The bounds of this DropInfo.  # noqa: E501
        :type: Bounds
        """

        self._bounds = bounds

    @property
    def drop_type(self):
        """Gets the drop_type of this DropInfo.  # noqa: E501


        :return: The drop_type of this DropInfo.  # noqa: E501
        :rtype: str
        """
        return self._drop_type

    @drop_type.setter
    def drop_type(self, drop_type):
        """Sets the drop_type of this DropInfo.


        :param drop_type: The drop_type of this DropInfo.  # noqa: E501
        :type: str
        """
        allowed_values = ["NORMAL_DROP", "EXTRA_DROP", "SPECIAL_DROP", "FURNITURE"]  # noqa: E501
        if drop_type not in allowed_values:
            raise ValueError(
                "Invalid value for `drop_type` ({0}), must be one of {1}"  # noqa: E501
                .format(drop_type, allowed_values)
            )

        self._drop_type = drop_type

    @property
    def item_id(self):
        """Gets the item_id of this DropInfo.  # noqa: E501

        If itemId is null, the `bounds` property means the limitation in the number of different item kinds in a certain drop type.  # noqa: E501

        :return: The item_id of this DropInfo.  # noqa: E501
        :rtype: str
        """
        return self._item_id

    @item_id.setter
    def item_id(self, item_id):
        """Sets the item_id of this DropInfo.

        If itemId is null, the `bounds` property means the limitation in the number of different item kinds in a certain drop type.  # noqa: E501

        :param item_id: The item_id of this DropInfo.  # noqa: E501
        :type: str
        """

        self._item_id = item_id

    @property
    def server(self):
        """Gets the server of this DropInfo.  # noqa: E501


        :return: The server of this DropInfo.  # noqa: E501
        :rtype: str
        """
        return self._server

    @server.setter
    def server(self, server):
        """Sets the server of this DropInfo.


        :param server: The server of this DropInfo.  # noqa: E501
        :type: str
        """
        allowed_values = ["CN", "US", "JP", "KR"]  # noqa: E501
        if server not in allowed_values:
            raise ValueError(
                "Invalid value for `server` ({0}), must be one of {1}"  # noqa: E501
                .format(server, allowed_values)
            )

        self._server = server

    @property
    def stage_id(self):
        """Gets the stage_id of this DropInfo.  # noqa: E501


        :return: The stage_id of this DropInfo.  # noqa: E501
        :rtype: str
        """
        return self._stage_id

    @stage_id.setter
    def stage_id(self, stage_id):
        """Sets the stage_id of this DropInfo.


        :param stage_id: The stage_id of this DropInfo.  # noqa: E501
        :type: str
        """

        self._stage_id = stage_id

    @property
    def time_range(self):
        """Gets the time_range of this DropInfo.  # noqa: E501


        :return: The time_range of this DropInfo.  # noqa: E501
        :rtype: TimeRange
        """
        return self._time_range

    @time_range.setter
    def time_range(self, time_range):
        """Sets the time_range of this DropInfo.


        :param time_range: The time_range of this DropInfo.  # noqa: E501
        :type: TimeRange
        """

        self._time_range = time_range

    @property
    def time_range_id(self):
        """Gets the time_range_id of this DropInfo.  # noqa: E501


        :return: The time_range_id of this DropInfo.  # noqa: E501
        :rtype: str
        """
        return self._time_range_id

    @time_range_id.setter
    def time_range_id(self, time_range_id):
        """Sets the time_range_id of this DropInfo.


        :param time_range_id: The time_range_id of this DropInfo.  # noqa: E501
        :type: str
        """

        self._time_range_id = time_range_id

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(DropInfo, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DropInfo):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
